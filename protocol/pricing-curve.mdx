---
title: 'Pricing Curve'
description: 'The deterministic bonding curve that governs Moony pricing'
icon: chart-line
---

<div style={{ backgroundColor: '#E7D9FD', borderRadius: '1rem', padding: '0', overflow: 'hidden', marginBottom: '1.5rem' }}>
  <img src="/images/pattern2.png" alt="Moony Pattern" style={{ borderRadius: '1rem', width: '100%' }} />
</div>

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
Moony's price discovery is governed by an onchain bonding curve - a deterministic exponential function encoded within the Moony Reserve smart contract. Unlike traditional market-based price discovery that relies on order books or automated market makers (AMMs) with liquidity pools, the bonding curve calculates the price of MNY based solely on the current circulating supply. As tokens enter circulation through unlocking, the price rises along a mathematically defined trajectory. As tokens are redeemed and removed from circulation, the price falls along the same curve in reverse.
</p>

<p style={{ marginBottom: '1.5rem' }}>
The exponential model was selected for its specific economic properties: gradual price appreciation during early adoption phases, accelerating value capture as the network matures, and a natural ceiling that bounds maximum token price. This creates predictable incentive structures where early participants benefit from lower entry prices while later participants contribute proportionally more capital to the reserve - capital that backs the redemption value of all circulating tokens.
</p>

<p style={{ marginBottom: '1.5rem' }}>
This mechanism applies symmetrically to both unlocking and redemption using identical mathematical functions. All participants interact with the same pricing logic, enforced by immutable onchain code with no administrative override capability. Prices cannot be altered, manipulated, or manually adjusted by any party. All transaction outcomes are independently verifiable and reproducible using the formulas and constants documented below.
</p>

</div>

## Spot Price

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
The spot price represents the instantaneous price per MNY token at any given circulating supply level. In bonding curve terminology, "spot price" refers to the marginal cost of the next infinitesimally small unit of tokens - the derivative of the cumulative cost function. This differs from traditional market spot prices, which reflect the last traded price between counterparties. Here, the spot price is a continuous mathematical function with no bid-ask spread, no slippage on infinitesimal trades, and no dependence on external liquidity or market sentiment.
</p>

<p style={{ marginBottom: '1.5rem' }}>
The spot price function is defined by an exponential equation with three immutable constants:
</p>

</div>

<div className="principle-card formula-card" style={{
  padding: '1.5rem',
  marginBottom: '1.5rem'
}}>
  <div className="formula-box">
    $$
    P(S) = a \times b \times e^{c \times S}
    $$
  </div>
  <div className="formula-explanation">
    <div style={{ marginTop: '0' }}>
      <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>P(S)</code> - spot price in USDF at supply level S
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S</code> - current circulating supply of MNY tokens
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>e</code> - Euler's number (~2.71828), the base of the natural exponential function
        </li>
      </ul>
      <p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem', color: '#475569' }}>
        The exponential form ensures that the rate of price change is proportional to the current price itself - a property that creates smooth, continuous appreciation without discontinuities or arbitrage opportunities at any supply level.
      </p>
    </div>
  </div>
</div>

### Constants

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
The three constants that parameterize the curve were derived to satisfy specific boundary conditions: an initial price of approximately 0.01 USDF when supply approaches zero, a terminal price of 1,000,000 USDF at maximum supply (21,000,000 MNY), and a growth rate that produces a smooth, continuous price trajectory between these bounds. These values are immutably encoded in the Moony Reserve smart contract and cannot be modified after deployment:
</p>

</div>

<div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginTop: '1.5rem', marginBottom: '2rem' }}>

  <div className="principle-card" style={{
    border: '1px solid #e5e7eb',
    borderRadius: '0.75rem',
    padding: '1.5rem',
    marginBottom: '0',
    backgroundColor: '#ffffff',
    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
  }}>
    <div style={{
      fontSize: '1rem',
      fontWeight: 600,
      color: '#1e293b'
    }}>
      <code style={{
        fontFamily: 'monospace',
        color: '#502792',
        backgroundColor: 'transparent',
        padding: 0
      }}>a</code> = 11400.230149967394933471
    </div>
    <p style={{
      margin: 0,
      lineHeight: '1.6',
      color: '#475569',
      fontSize: '0.9375rem'
    }}>
      Amplitude constant  - scales the curve to reach $1,000,000 USDF at maximum supply.
    </p>
  </div>

  <div className="principle-card" style={{
    border: '1px solid #e5e7eb',
    borderRadius: '0.75rem',
    padding: '1.5rem',
    marginBottom: '0',
    backgroundColor: '#ffffff',
    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
  }}>
    <div style={{
      fontSize: '1rem',
      fontWeight: 600,
      color: '#1e293b'
    }}>
      <code style={{
        fontFamily: 'monospace',
        color: '#502792',
        backgroundColor: 'transparent',
        padding: 0
      }}>b</code> = 0.000000877175273521
    </div>
    <p style={{
      margin: 0,
      lineHeight: '1.6',
      color: '#475569',
      fontSize: '0.9375rem'
    }}>
      Initial price coefficient  - sets the starting price at a × b ≈ $0.01 USDF when supply is near zero.
    </p>
  </div>

  <div className="principle-card" style={{
    border: '1px solid #e5e7eb',
    borderRadius: '0.75rem',
    padding: '1.5rem',
    marginBottom: '0',
    backgroundColor: '#ffffff',
    boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
  }}>
    <div style={{
      fontSize: '1rem',
      fontWeight: 600,
      color: '#1e293b'
    }}>
      <code style={{
        fontFamily: 'monospace',
        color: '#502792',
        backgroundColor: 'transparent',
        padding: 0
      }}>c</code> = 0.000000877175273521
    </div>
    <p style={{
      margin: 0,
      lineHeight: '1.6',
      color: '#475569',
      fontSize: '0.9375rem'
    }}>
      Growth rate  - controls how rapidly price increases with supply. Note: c = b by design, which simplifies integral calculations.
    </p>
  </div>

</div>

### Price at Supply Milestones

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
The following reference table illustrates spot prices at key supply milestones, demonstrating the exponential growth characteristic of the curve. These values are computed directly from the spot price formula and can be independently verified:
</p>

</div>

<div className="table-card" style={{
  border: '1px solid #e5e7eb',
  borderRadius: '0.75rem',
  padding: '1.5rem',
  marginBottom: '1.5rem',
  boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)'
}}>

| Circulating Supply | Spot Price (USDF) |
|-------------------|-------------------|
| 0 | 0.01 |
| 1,000,000 | 0.02 |
| 5,000,000 | 0.80 |
| 10,000,000 | 64.50 |
| 15,000,000 | 5,180 |
| 20,000,000 | 415,000 |
| 21,000,000 | 1,000,000 |

<p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem' }}>
The price trajectory exhibits the characteristic "hockey stick" shape of exponential growth: relatively stable through the first half of supply distribution (0-10M tokens), followed by rapid acceleration as supply approaches the 21M maximum. This distribution creates strong incentives for early participation while ensuring that later entrants contribute substantially more capital per token to the reserve - capital that enhances the redemption backing for all token holders.
</p>

</div>

## Transaction Pricing

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
While the spot price defines the instantaneous cost of an infinitesimal token quantity, actual transactions involve discrete token amounts. The total cost or value of a transaction is computed by integrating the spot price function over the supply range traversed during the transaction - mathematically equivalent to calculating the area under the curve between two supply points.
</p>

<p style={{ marginBottom: '1.5rem' }}>
This integral-based approach ensures that transaction pricing is path-independent and deterministic: the cost to acquire tokens from supply S₁ to S₂ is identical regardless of whether the transaction occurs in a single operation or multiple smaller transactions. The formulas below represent closed-form solutions to these integrals, enabling efficient onchain computation without numerical approximation.
</p>

</div>

### Cost to Buy Tokens

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
Given a desired quantity of tokens to acquire, this formula computes the total USDF cost. The result represents the definite integral of the spot price function from current supply to new supply - the exact area under the exponential curve across the transaction range:
</p>

</div>

<div className="principle-card formula-card" style={{
  padding: '1.5rem',
  marginBottom: '1.5rem'
}}>
  <div className="formula-box">
    $$
    Cost = \frac{a \cdot b}{c} \cdot \left( e^{c \cdot S_1} - e^{c \cdot S_0} \right)
    $$
  </div>
  <div className="formula-explanation">
    <div style={{ marginTop: '0' }}>
      <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S₀</code> - circulating supply before the purchase (currentSupply)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S₁</code> - circulating supply after the purchase (S₀ + tokensToBuy)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          Since b = c by design, the coefficient (a · b / c) simplifies to <code style={{ backgroundColor: 'transparent', padding: 0 }}>a</code>
        </li>
      </ul>
      <p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem', color: '#475569' }}>
        The computed cost always exceeds (spot price × quantity) because each successive token in the transaction is priced marginally higher than the previous. This price impact is an inherent property of bonding curves and scales with transaction size relative to total supply.
      </p>
    </div>
  </div>
</div>

### Tokens Bought for Value

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
In practice, participants typically specify a USDF amount to spend rather than a token quantity to acquire. This inverse function - derived by solving the cost integral for the unknown upper bound - determines the exact quantity of MNY tokens received for a given USDF expenditure. This is the primary calculation executed during token acquisition in client applications:
</p>

</div>

<div className="principle-card formula-card" style={{
  padding: '1.5rem',
  marginBottom: '1.5rem'
}}>
  <div className="formula-box">
    $$
    T = \frac{\ln\left(\frac{V}{a} + e^{c \cdot S_0}\right)}{c} - S_0
    $$
  </div>
  <div className="formula-explanation">
    <div style={{ marginTop: '0' }}>
      <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>T</code> - tokens received (tokensBought)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>V</code> - USDF amount the participant wishes to spend
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S₀</code> - circulating supply before the purchase
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>ln</code> - natural logarithm, the inverse of exponentiation (e^x)
        </li>
      </ul>
      <p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem', color: '#475569' }}>
        The logarithmic term arises from inverting the exponential cost function. Because the natural log is the inverse of e^x, this formula algebraically solves for the supply endpoint that yields exactly the specified cost when integrated from S₀.
      </p>
    </div>
  </div>
</div>

### Value from Selling Tokens

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
Redemption operates symmetrically to acquisition: tokens are returned to the reserve, circulating supply decreases, and USDF is released to the participant. The value received is computed by integrating the spot price function in reverse - from the current supply down to the post-redemption supply level:
</p>

</div>

<div className="principle-card formula-card" style={{
  padding: '1.5rem',
  marginBottom: '1.5rem'
}}>
  <div className="formula-box">
    $$
    Value = \frac{a \cdot b}{c} \cdot \left( e^{c \cdot S_0} - e^{c \cdot S_1} \right)
    $$
  </div>
  <div className="formula-explanation">
    <div style={{ marginTop: '0' }}>
      <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S₀</code> - circulating supply before the redemption
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>S₁</code> - circulating supply after the redemption (S₀ - tokensToSell)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          Returns the gross redemption value before protocol fees are applied
        </li>
      </ul>
      <p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem', color: '#475569' }}>
        The mathematical symmetry between acquisition and redemption ensures that the reserve always holds sufficient USDF to honor all outstanding redemptions at current curve prices. This is a fundamental solvency invariant of the bonding curve design - the integrated value locked in the reserve exactly equals the integrated redemption value of all circulating tokens.
      </p>
    </div>
  </div>
</div>

### Tokens Required for Value

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
Similar to acquisition, redemption flows in client applications typically specify a desired USDF amount to receive rather than a token quantity to redeem. This inverse function computes the exact number of MNY tokens that must be returned to the reserve to release the specified USDF value. The formula operates on reserve value rather than supply, providing an equivalent but computationally distinct approach:
</p>

</div>

<div className="principle-card formula-card" style={{
  padding: '1.5rem',
  marginBottom: '1.5rem'
}}>
  <div className="formula-box">
    $$
    T = \frac{1}{c} \cdot \left[ \ln\left(1 + \frac{V_0}{a}\right) - \ln\left(1 + \frac{V_1}{a}\right) \right]
    $$
  </div>
  <div className="formula-explanation">
    <div style={{ marginTop: '0' }}>
      <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>T</code> - tokens required to sell (tokensToSell)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>V₀</code> - total USDF currently locked in the reserve
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>V₁</code> - reserve balance after redemption (V₀ - valueToReceive)
        </li>
        <li style={{ marginBottom: '0.5rem' }}>
          <code style={{ backgroundColor: 'transparent', padding: 0 }}>ln</code> - natural logarithm, the inverse of exponentiation (e^x)
        </li>
      </ul>
      <p style={{ marginTop: '1rem', marginBottom: 0, fontSize: '0.9375rem', color: '#475569' }}>
        This formulation uses the reserve's locked value as the state variable rather than circulating supply. The two representations are mathematically equivalent due to the one-to-one correspondence between supply levels and cumulative reserve value defined by the bonding curve integral.
      </p>
    </div>
  </div>
</div>

<Info>
Redemptions are subject to a fee (in basis points) deducted from the gross value. See the <a href="/protocol/proof-of-capital#fee-model" className="brand-link">Fee Model</a> section for details.
</Info>

### Worked Example

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1rem' }}>
The following example demonstrates the cost calculation for a token acquisition, illustrating how the integral-based pricing produces a result that differs from simple spot price multiplication. Consider a transaction where the current circulating supply is 1,000,000 MNY and a participant seeks to acquire 10,000 tokens:
</p>

</div>

<div className="principle-card" style={{
  border: '1px solid #e5e7eb',
  borderRadius: '0.75rem',
  padding: '1.5rem',
  marginBottom: '1.5rem',
  backgroundColor: '#f8fafc'
}}>
  <div style={{ marginBottom: '1rem' }}>
    <strong>Given:</strong>
    <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
      <li>currentSupply = 1,000,000</li>
      <li>tokensToBuy = 10,000</li>
      <li>newSupply = 1,010,000</li>
    </ul>
  </div>
  <div style={{ marginBottom: '1rem' }}>
    <strong>Calculation:</strong>
    <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
      <li>Cost = a × (e^(c × newSupply) - e^(c × currentSupply))</li>
      <li>Cost = 11,400.23 × (e^0.8859 - e^0.8772)</li>
      <li>Cost = 11,400.23 × (2.4250 - 2.4039)</li>
      <li>Cost = 11,400.23 × 0.0211</li>
    </ul>
  </div>
  <div>
    <strong>Result:</strong>
    <ul style={{ marginTop: '0.5rem', marginBottom: 0, paddingLeft: '1.5rem' }}>
      <li>Total cost: ~240.54 USDF</li>
      <li>Average price per token: ~0.024 USDF</li>
      <li>Spot price at entry: ~0.024 USDF</li>
      <li>Spot price at exit: ~0.024 USDF</li>
    </ul>
  </div>
</div>

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
The average execution price of 0.024 USDF per token is marginally higher than the spot price at the transaction's starting supply level. This differential - commonly referred to as "price impact" or "slippage" in trading contexts - arises because the transaction traverses the curve: each successive token in the batch is priced at a marginally higher point along the exponential function. For this example, acquiring 10,000 tokens (1% of the starting supply) results in minimal price impact. Larger transactions relative to current supply would exhibit proportionally greater deviation between entry spot price and average execution price.
</p>

</div>

## Discrete Implementation

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
While the continuous formulas above define the mathematical specification of the pricing curve, direct onchain computation of exponential and logarithmic functions presents practical challenges. These transcendental functions require iterative approximation algorithms that consume significant computational resources (gas) and introduce potential precision variance across different implementations. To address these constraints while preserving exact mathematical correctness, the Moony Reserve employs a discrete implementation based on precomputed lookup tables.
</p>

<p style={{ marginBottom: '1.5rem' }}>
This approach precomputes all curve values at regular supply intervals, storing them as fixed-point integers in contract storage. Transaction pricing then reduces to table lookups with linear interpolation between adjacent entries - operations that are computationally efficient and produce bit-identical results across all execution environments.
</p>

</div>

### Lookup Tables

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1rem' }}>
The discrete implementation maintains two parallel data structures, each containing values precomputed from the continuous formulas at fixed supply intervals:
</p>

<ul style={{ marginBottom: '1.5rem', paddingLeft: '1.5rem' }}>
  <li style={{ marginBottom: '0.75rem' }}>
    <strong>Discrete Pricing Table</strong> - contains the spot price P(S) evaluated at each discrete supply level. Used for displaying current market price and computing marginal costs.
  </li>
  <li style={{ marginBottom: '0.75rem' }}>
    <strong>Discrete Cumulative Value Table</strong> - contains the definite integral of P(S) from 0 to each discrete supply level. Enables O(1) transaction cost computation by subtracting cumulative values at transaction boundaries.
  </li>
</ul>

<p style={{ marginBottom: '1.5rem' }}>
During transaction execution, the contract identifies the table entries bracketing the current and target supply levels, retrieves the corresponding values, and applies linear interpolation for sub-interval precision. This produces results that match the continuous formulas to within the interpolation error bound, which is negligible at the configured step size.
</p>

</div>

### Precision

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1rem' }}>
The lookup tables are configured with the following precision parameters, balancing storage efficiency against interpolation accuracy:
</p>

<ul style={{ marginBottom: '1.5rem', paddingLeft: '1.5rem' }}>
  <li style={{ marginBottom: '0.75rem' }}>
    <strong>Step size</strong>: 100 tokens - each table entry at index i represents the curve value at supply S = i × 100. This granularity ensures interpolation error remains below 0.01% for typical transaction sizes.
  </li>
  <li style={{ marginBottom: '0.75rem' }}>
    <strong>Decimal precision</strong>: 18 decimal places - all values are stored as integers scaled by 10^18, matching the standard ERC-20 decimal convention and preserving full precision through arithmetic operations.
  </li>
  <li style={{ marginBottom: '0.75rem' }}>
    <strong>Total entries</strong>: 210,001 per table - covering all supply levels from 0 through the 21,000,000 MNY maximum in 100-token increments.
  </li>
</ul>

</div>

### Verification

<div style={{ textAlign: 'justify' }}>

<p style={{ marginBottom: '1.5rem' }}>
The lookup tables are fully deterministic and independently verifiable. Given the constants (a, b, c) and formulas documented above, any implementation can regenerate the complete table contents and verify byte-for-byte equivalence with the deployed contract data. This verifiability extends to transaction outcomes: given the pre-transaction supply and transaction parameters, the resulting cost or value can be computed offline and compared against the onchain execution result. Any discrepancy would indicate either an implementation error or contract compromise - neither of which is possible given the immutable, audited nature of the deployed code.
</p>

</div>
